import logging
import feedparser
from datetime import datetime, timezone
from telegram import Update, ReplyKeyboardMarkup, ReplyKeyboardRemove
from telegram.ext import (
    Application, CommandHandler, ConversationHandler, MessageHandler, filters, ContextTypes
)
import os
import json

# Включаем логирование
logging.basicConfig(
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    level=logging.INFO
)

# Ваш API токен от BotFather
TELEGRAM_BOT_TOKEN = '8160585326:AAFmDXtbF9sJ4jCfkBYj0RA14Rj15BnyKvo'

# Глобальный список источников новостей
NEWS_SOURCES = [
    'https://9to5google.com/feed/',
    'https://www.independent.co.uk/topic/google/rss',
    'https://feeds.macrumors.com/MacRumors-All',
    'https://www.independent.co.uk/topic/apple/rss',
    'https://9to5mac.com/feed/',
    'https://www.reddit.com/r/apple/.rss',
    'https://www.reddit.com/r/iphone/.rss',
    'https://www.reddit.com/r/ios/.rss',
    'https://www.reddit.com/r/oneui/.rss',
    'https://www.reddit.com/r/GalaxyWatch/.rss',
    'https://www.sammobile.com/feed/',
    'https://www.gsmarena.com/rss-news-reviews.php3',
    'https://www.androidpolice.com/feed/',
    'https://www.zdnet.com/news/rss.xml'
]

SENT_ARTICLES_FILE = 'sent_articles.json'
KEYWORDS_FILE = 'user_keywords.json'
ADMIN_CHAT_ID = '1404964913'

# Состояния для ConversationHandler
ADD_KEYWORD, CONFIRM_MORE, DELETE_KEYWORD, BROADCAST_MESSAGE = range(4)

# Словари для хранения данных
user_keywords = {}
sent_articles = {}

# Загрузка данных из файлов
def load_json_file(filename, default):
    if os.path.exists(filename):
        try:
            with open(filename, 'r', encoding='utf-8') as f:
                return json.load(f)
        except Exception as e:
            logging.error(f"Ошибка при загрузке {filename}: {e}")
            return default
    return default

# Сохранение данных в файлы
def save_json_file(data, filename):
    try:
        with open(filename, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=4)
        logging.info(f"Данные сохранены в файл {filename}.")
    except Exception as e:
        logging.error(f"Ошибка при сохранении в файл {filename}: {e}")

# Функции для работы с последней проверкой новостей
def load_last_checked(chat_id):
    """Загружаем время последней проверки для определенного пользователя."""
    last_checked_file = f'{chat_id}_last_checked.txt'
    try:
        if os.path.exists(last_checked_file):
            with open(last_checked_file, 'r') as file:
                timestamp = file.read().strip()
                last_checked = datetime.fromisoformat(timestamp)
                if last_checked.tzinfo is None:
                    last_checked = last_checked.replace(tzinfo=timezone.utc)
                return last_checked
    except Exception as e:
        logging.error(f"Ошибка при загрузке времени последней проверки для {chat_id}: {e}")
    return datetime.now(timezone.utc)

def save_last_checked(chat_id, timestamp):
    """Сохраняем время последней проверки для определенного пользователя."""
    last_checked_file = f'{chat_id}_last_checked.txt'
    try:
        with open(last_checked_file, 'w') as file:
            file.write(timestamp.isoformat())
    except Exception as e:
        logging.error(f"Ошибка при сохранении времени последней проверки для {chat_id}: {e}")

def parse_pub_date(pub_date_str):
    """Разбор строки даты публикации."""
    date_formats = [
        '%a, %d %b %Y %H:%M:%S %z',  # Стандартный формат RSS
        '%Y-%m-%dT%H:%M:%S%z',        # ISO 8601 формат
        '%a, %d %b %Y %H:%M:%S %Z',   # Вариант без часового пояса
        '%Y-%m-%dT%H:%M:%S.%fZ',      # ISO 8601 с миллисекундами
    ]
    for date_format in date_formats:
        try:
            return datetime.strptime(pub_date_str, date_format)
        except ValueError:
            continue
    logging.warning(f"Не удалось распознать дату: {pub_date_str}")
    return datetime.now(timezone.utc)

def get_latest_articles(url):
    """Получаем последние статьи из RSS-ленты."""
    try:
        feed = feedparser.parse(url)
        if not feed.entries:
            logging.warning(f'Нет статей в ленте по URL: {url}')
            return []

        articles = []
        for entry in feed.entries:
            title = entry.get('title', 'Без заголовка')
            link = entry.get('link')
            pub_date_str = entry.get('published', '')
            if not link:
                continue

            pub_date = parse_pub_date(pub_date_str) if pub_date_str else datetime.now(timezone.utc)
            if pub_date.tzinfo is None:
                pub_date = pub_date.replace(tzinfo=timezone.utc)

            logging.info(f"Получена статья: '{title}' с ссылкой {link} и датой {pub_date}")

            articles.append({
                'title': title,
                'link': link,
                'pub_date': pub_date
            })
        return articles
    except Exception as e:
        logging.error(f"Ошибка при обработке URL {url}: {e}")
        return []

async def send_new_articles(context: ContextTypes.DEFAULT_TYPE):
    """Проверяем и отправляем новые статьи, фильтруя по ключевым словам."""
    logging.info("Проверка новых статей...")

    sent_articles = load_json_file(SENT_ARTICLES_FILE, {})
    # Преобразуем списки обратно в множества
    sent_articles = {chat_id: set(articles) for chat_id, articles in sent_articles.items()}

    for chat_id, keywords in user_keywords.items():
        last_checked = load_last_checked(chat_id)
        new_last_checked = datetime.now(timezone.utc)

        if chat_id not in sent_articles:
            sent_articles[chat_id] = set()

        for url in NEWS_SOURCES:
            articles = get_latest_articles(url)
            for article in articles:
                if article['pub_date'] > last_checked and article['link'] not in sent_articles[chat_id]:
                    if any(keyword.lower() in article['title'].lower() for keyword in keywords):
                        message = f"*{article['title']}*\n[Читать далее]({article['link']})"
                        try:
                            await context.bot.send_message(
                                chat_id=chat_id,
                                text=message,
                                parse_mode='Markdown'
                            )
                            logging.info(f"Отправлена статья '{article['title']}' пользователю {chat_id}")
                            sent_articles[chat_id].add(article['link'])
                        except Exception as e:
                            logging.error(f"Ошибка отправки статьи пользователю {chat_id}: {e}")
                    else:
                        logging.info(f"Статья '{article['title']}' не подходит по ключевым словам для пользователя {chat_id}")

        save_last_checked(chat_id, new_last_checked)

    # Преобразуем множества обратно в списки перед сохранением
    sent_articles_to_save = {chat_id: list(articles) for chat_id, articles in sent_articles.items()}
    save_json_file(sent_articles_to_save, SENT_ARTICLES_FILE)

# Команды для работы с ключевыми словами
async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Ответ на команду /start."""
    chat_id = str(update.message.chat_id)
    if chat_id not in user_keywords:
        user_keywords[chat_id] = []
    await update.message.reply_text(
        'Добро пожаловать! Вы можете добавить ключевые слова с помощью команды /add_keyword.'
    )

# Диалог для добавления ключевых слов
async def add_keyword_start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Начало процесса добавления ключевого слова."""
    await update.message.reply_text(
        "Какое ключевое слово вы хотите добавить?",
        reply_markup=ReplyKeyboardRemove()
    )
    return ADD_KEYWORD

async def add_keyword_finish(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Добавление ключевого слова после ввода."""
    chat_id = str(update.message.chat_id)
    keyword = update.message.text.strip().lower()

    if chat_id not in user_keywords:
        user_keywords[chat_id] = []

    user_keywords[chat_id].append(keyword)
    save_json_file(user_keywords, KEYWORDS_FILE)

    await update.message.reply_text(f"Ключевое слово '{keyword}' добавлено.")

    reply_keyboard = [['Да', 'Нет']]
    await update.message.reply_text(
        "Хотите добавить ещё одно ключевое слово?",
        reply_markup=ReplyKeyboardMarkup(reply_keyboard, one_time_keyboard=True)
    )
    return CONFIRM_MORE

async def add_keyword_more(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Обработка ответа на вопрос о добавлении ещё одного слова."""
    if update.message.text.lower() == 'да':
        await update.message.reply_text("Введите новое ключевое слово:", reply_markup=ReplyKeyboardRemove())
        return ADD_KEYWORD
    else:
        await update.message.reply_text("Добавление ключевых слов завершено.", reply_markup=ReplyKeyboardRemove())
        return ConversationHandler.END

# Диалог для удаления ключевых слов
async def delete_keyword_start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Начало процесса удаления ключевого слова."""
    chat_id = str(update.message.chat_id)

    if chat_id not in user_keywords or not user_keywords[chat_id]:
        await update.message.reply_text("У вас нет сохраненных ключевых слов для удаления.")
        return ConversationHandler.END

    keywords_list = user_keywords[chat_id]
    keyword_message = "\n".join([f"{i+1}. {kw}" for i, kw in enumerate(keywords_list)])
    await update.message.reply_text(f"Ваши ключевые слова:\n{keyword_message}\n\nВведите номер ключевого слова для удаления.")
    return DELETE_KEYWORD

async def delete_keyword_finish(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Удаление ключевого слова после ввода номера."""
    chat_id = str(update.message.chat_id)
    try:
        keyword_index = int(update.message.text.strip()) - 1
        keywords_list = user_keywords[chat_id]

        if keyword_index < 0 or keyword_index >= len(keywords_list):
            await update.message.reply_text("Неверный номер ключевого слова. Пожалуйста, попробуйте снова.")
            return DELETE_KEYWORD

        removed_keyword = keywords_list.pop(keyword_index)
        save_json_file(user_keywords, KEYWORDS_FILE)
        await update.message.reply_text(f"Ключевое слово '{removed_keyword}' удалено.", reply_markup=ReplyKeyboardRemove())
    except ValueError:
        await update.message.reply_text("Пожалуйста, введите корректный номер ключевого слова.")
        return DELETE_KEYWORD

    return ConversationHandler.END

# Отмена действия
async def cancel(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Отмена текущего диалога."""
    await update.message.reply_text('Действие отменено.', reply_markup=ReplyKeyboardRemove())
    return ConversationHandler.END

# Команда /broadcast
async def broadcast_start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Начало процесса отправки сообщения всем пользователям (только для администратора)."""
    chat_id = str(update.message.chat_id)
    if chat_id != ADMIN_CHAT_ID:
        await update.message.reply_text("Извините, эта команда доступна только администратору.")
        return ConversationHandler.END

    await update.message.reply_text(
        "Введите сообщение для рассылки всем пользователям или отправьте изображение:",
        reply_markup=ReplyKeyboardRemove()
    )
    return BROADCAST_MESSAGE

async def broadcast_send(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Отправка сообщения или изображения всем пользователям."""
    chat_id = str(update.message.chat_id)
    if chat_id != ADMIN_CHAT_ID:
        await update.message.reply_text("Извините, эта команда доступна только администратору.")
        return ConversationHandler.END

    broadcast_message = update.message.text
    photo = update.message.photo[-1].file_id if update.message.photo else None

    for user_chat_id in user_keywords.keys():
        try:
            if photo and broadcast_message:
                await context.bot.send_photo(
                    chat_id=user_chat_id,
                    photo=photo,
                    caption=broadcast_message
                )
            elif photo:
                await context.bot.send_photo(
                    chat_id=user_chat_id,
                    photo=photo
                )
            elif broadcast_message:
                await context.bot.send_message(
                    chat_id=user_chat_id,
                    text=broadcast_message
                )
            logging.info(f"Отправлено сообщение пользователю {user_chat_id}")
        except Exception as e:
            logging.error(f"Ошибка отправки сообщения пользователю {user_chat_id}: {e}")

    await update.message.reply_text("Сообщение отправлено всем пользователям.")
    return ConversationHandler.END

# Основная функция для запуска бота
def main():
    """Основная функция для запуска бота."""
    global user_keywords
    user_keywords = load_json_file(KEYWORDS_FILE, {})

    application = Application.builder().token(TELEGRAM_BOT_TOKEN).build()

    # Определение ConversationHandler для добавления ключевого слова
    add_keyword_conv_handler = ConversationHandler(
        entry_points=[CommandHandler('add_keyword', add_keyword_start)],
        states={
            ADD_KEYWORD: [MessageHandler(filters.TEXT & ~filters.COMMAND, add_keyword_finish)],
            CONFIRM_MORE: [MessageHandler(filters.Regex('^(Да|Нет)$'), add_keyword_more)],
        },
        fallbacks=[CommandHandler('cancel', cancel)]
    )

    # Определение ConversationHandler для удаления ключевого слова
    delete_keyword_conv_handler = ConversationHandler(
        entry_points=[CommandHandler('delete_keyword', delete_keyword_start)],
        states={
            DELETE_KEYWORD: [MessageHandler(filters.TEXT & ~filters.COMMAND, delete_keyword_finish)],
        },
        fallbacks=[CommandHandler('cancel', cancel)]
    )

    # Определение ConversationHandler для команды /broadcast
    broadcast_conv_handler = ConversationHandler(
        entry_points=[CommandHandler('broadcast', broadcast_start)],
        states={
            BROADCAST_MESSAGE: [
                MessageHandler(filters.TEXT & ~filters.COMMAND, broadcast_send),
                MessageHandler(filters.PHOTO, broadcast_send),
            ],
        },
        fallbacks=[CommandHandler('cancel', cancel)],
    )

    application.add_handler(CommandHandler('start', start))
    application.add_handler(add_keyword_conv_handler)
    application.add_handler(delete_keyword_conv_handler)
    application.add_handler(broadcast_conv_handler)

    # Добавляем задачу для регулярной проверки новостей
    job_queue = application.job_queue
    job_queue.run_repeating(
        send_new_articles,
        interval=60,  # 1 минута
        first=30,
        name='send_new_articles'
    )

    # Запуск бота
    application.run_polling()

if __name__ == '__main__':
    main()